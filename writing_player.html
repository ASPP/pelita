<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Writing a Player &mdash; Pelita v0.2.0-102-ge1e65a9 documentation</title>
    
    <link rel="stylesheet" href="_static/pelita.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-2.3.2/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootswatch/2.3.2/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-2.3.2/css/bootstrap-responsive.min.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'v0.2.0-102-ge1e65a9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.9.1.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-2.3.2/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Pelita v0.2.0-102-ge1e65a9 documentation" href="index.html" />
    <link rel="next" title="Running Players" href="running_player.html" />
    <link rel="prev" title="Project Information" href="info.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>
  
  <a href="https://github.com/ASPP/pelita"
     class="visible-desktop"><img
    style="position: absolute; top: 56; right: 0; "
    src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png"
    alt="Fork me on GitHub"></a>


  <div id="navbar" class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <a class="brand" href="index.html">Pelita</a>
        <span class="navbar-text pull-left"><b>v0.2.0-102-ge1e65a9</b></span>

        <div class="nav-collapse">
          <ul class="nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a href="index.html"
     class="dropdown-toggle"
     data-toggle="dropdown">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
    ><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="info.html">Project Information</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Writing a Player</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_player.html">Running Players</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="user-api.html">User API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API reference</a></li>
</ul>
</ul>
</li>
              <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"><ul>
<li><a class="reference internal" href="#">Writing a Player</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#player-basics">Player Basics</a></li>
<li><a class="reference internal" href="#doing-more">Doing More</a></li>
<li><a class="reference internal" href="#the-maze-coordinate-system">The Maze Coordinate System</a><ul>
<li><a class="reference internal" href="#distances-in-the-maze">Distances in the Maze</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-basic-offensive-player">A Basic Offensive Player</a><ul>
<li><a class="reference internal" href="#current-uni-current-state-current-pos-and-enemy-food"><tt class="docutils literal"><span class="pre">current_uni</span></tt>, <tt class="docutils literal"><span class="pre">current_state</span></tt>, <tt class="docutils literal"><span class="pre">current_pos</span></tt> and <tt class="docutils literal"><span class="pre">enemy_food</span></tt></a></li>
<li><a class="reference internal" href="#recovery-strategies-in-case-of-death-or-timeout">Recovery Strategies in Case of Death or Timeout</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interacting-with-the-maze">Interacting with the Maze</a></li>
<li><a class="reference internal" href="#a-basic-defensive-player">A Basic Defensive Player</a></li>
<li><a class="reference internal" href="#noisy-enemy-positions">Noisy Enemy Positions</a></li>
<li><a class="reference internal" href="#implementation-details-of-convenience-properties">Implementation Details of Convenience Properties</a></li>
</ul>
</li>
</ul>
</ul>
</li>
            
            
              
  <li><a href="info.html"
         title="Previous Chapter: Project Information">&laquo; Project Informat...</a></li>
  <li><a href="running_player.html"
         title="Next Chapter: Running Players">Running Players &raquo;</a></li>
            
            
              <li>
  <a href="_sources/writing_player.txt"
     rel="nofollow">Source</a></li>
            
          </ul>

          
            
<form class="navbar-search pull-right" action="search.html" method="get">
  <input type="text" name="q" class="search-query" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
      </div>
    </div>
  </div>

<div class="container">
  
  <div class="section" id="writing-a-player">
<span id="id1"></span><h1>Writing a Player<a class="headerlink" href="#writing-a-player" title="Permalink to this headline">¶</a></h1>
<p>This section explains how to write a player.</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>To begin with, we must define a few classes and some terminology which will be
used throughout this documentation.</p>
<dl class="docutils">
<dt><a class="reference internal" href="pelita/pelita.datamodel.CTFUniverse.html#pelita.datamodel.CTFUniverse" title="pelita.datamodel.CTFUniverse"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.datamodel.CTFUniverse</span></tt></a>:</dt>
<dd>The game state. Holds a list of <tt class="docutils literal"><span class="pre">Bot</span></tt> instances, a list of <tt class="docutils literal"><span class="pre">Team</span></tt>
instances and a single <tt class="docutils literal"><span class="pre">Maze</span></tt> object. Can be queried to obtain
information about the game.</dd>
<dt><a class="reference internal" href="pelita/pelita.datamodel.Bot.html#pelita.datamodel.Bot" title="pelita.datamodel.Bot"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.datamodel.Bot</span></tt></a>:</dt>
<dd>The data structure used to store the bot. This holds the position of the
<tt class="docutils literal"><span class="pre">Bot</span></tt> inside the Maze, its initial position, which team it belongs to
etc..</dd>
<dt><a class="reference internal" href="pelita/pelita.datamodel.Team.html#pelita.datamodel.Team" title="pelita.datamodel.Team"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.datamodel.Team</span></tt></a>:</dt>
<dd>In capture-the-flag each <tt class="docutils literal"><span class="pre">Bot</span></tt> belongs to a <tt class="docutils literal"><span class="pre">Team</span></tt>. The team stores the
indices of its bot, the score, the team name etc..</dd>
<dt><a class="reference internal" href="pelita/pelita.datamodel.Maze.html#pelita.datamodel.Maze" title="pelita.datamodel.Maze"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.datamodel.Maze</span></tt></a>:</dt>
<dd>Data structure that stores the maze or layout, i.e. where walls and food
are.</dd>
<dt><a class="reference internal" href="pelita/pelita.game_master.GameMaster.html#pelita.game_master.GameMaster" title="pelita.game_master.GameMaster"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.game_master.GameMaster</span></tt></a>:</dt>
<dd>Controller object that asks players for moves and updates the <tt class="docutils literal"><span class="pre">Universe</span></tt>.
You will never need to interact with this object but it&#8217;s good to know that
this is the central object that coordinates the game.</dd>
</dl>
<p>In addition to these classes there are two additional relevant concepts:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name"><tt class="docutils literal"><span class="pre">Player</span></tt>:</th><td class="field-body">Your implementation of the <em>intelligence</em> for a <tt class="docutils literal"><span class="pre">Bot</span></tt>. The abstraction is
that a <em>player</em> object controls a <em>bot</em> object.</td>
</tr>
<tr class="field-even field"><th class="field-name"><tt class="docutils literal"><span class="pre">move</span></tt>:</th><td class="field-body">A tuple that indicates where a <tt class="docutils literal"><span class="pre">Bot</span></tt> should move.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="player-basics">
<h2>Player Basics<a class="headerlink" href="#player-basics" title="Permalink to this headline">¶</a></h2>
<p>In order to write a player you should subclass from
<a class="reference internal" href="pelita/pelita.player.AbstractPlayer.html#pelita.player.AbstractPlayer" title="pelita.player.AbstractPlayer"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.player.AbstractPlayer</span></tt></a>. This is an abstract class which provides
several convenience methods and properties to interrogate the universe
including the bot instance that this player controls, but lacks the functions
to actually control the bot.</p>
<p>To subclass from <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt> import this with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pelita.player</span> <span class="kn">import</span> <span class="n">AbstractPlayer</span>
</pre></div>
</div>
<p>In order to make your player do something useful you must implement at least the
method <tt class="docutils literal"><span class="pre">get_move()</span></tt> to return a move. This can be one of:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
</pre></div>
</div>
<p>The moves are provided by the <a class="reference internal" href="pelita/pelita.datamodel.html#module-pelita.datamodel" title="pelita.datamodel"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.datamodel</span></tt></a>, import them with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pelita.datamodel</span> <span class="kn">import</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">stop</span>
</pre></div>
</div>
<p>An example of such a player is the trivial <a class="reference internal" href="pelita/pelita.player.StoppingPlayer.html#pelita.player.StoppingPlayer" title="pelita.player.StoppingPlayer"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.player.StoppingPlayer</span></tt></a>
which simply returns <tt class="docutils literal"><span class="pre">stop</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StoppingPlayer</span><span class="p">(</span><span class="n">AbstractPlayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A Player that just stands still. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">get_move</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">datamodel</span><span class="o">.</span><span class="n">stop</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Besides the definition of your player, this file must contain a factory
function that returns a team (remember that the default game is a
fight between two teams of two bots each):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">factory</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">SimpleTeam</span><span class="p">(</span><span class="s">&quot;MyTeam&quot;</span><span class="p">,</span> <span class="n">StoppingPlayer</span><span class="p">(),</span> <span class="n">StoppingPlayer</span><span class="p">())</span>
</pre></div>
</div>
<p class="last">For more information about this, see also:<a class="reference internal" href="running_player.html"><em>Running Players</em></a></p>
</div>
<p>Note: the current state or the <tt class="docutils literal"><span class="pre">CTFUniverse</span></tt> is always implicitly available
via the <tt class="docutils literal"><span class="pre">current_uni</span></tt> property inherited from <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt>. But more
about that later.</p>
</div>
<div class="section" id="doing-more">
<h2>Doing More<a class="headerlink" href="#doing-more" title="Permalink to this headline">¶</a></h2>
<p>A slightly more useful example is the <tt class="xref py py-obj docutils literal"><span class="pre">pelita.player.RandomPlayer</span></tt> which always
selects a move at random from the possible moves:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">RandomPlayer</span><span class="p">(</span><span class="n">AbstractPlayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A player that makes moves at random. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_move</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnd</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legal_moves</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>In the above example, we use an internal random number generator,
<tt class="xref py py-obj docutils literal"><span class="pre">self.rnd</span></tt> instead of the one from the <tt class="xref py py-obj docutils literal"><span class="pre">random</span></tt> module.</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">self.rnd</span></tt> is seeded by the <tt class="xref py py-obj docutils literal"><span class="pre">GameMaster</span></tt> during startup. This means
that whenever we initialise <tt class="xref py py-obj docutils literal"><span class="pre">GameMaster</span></tt> with the same seed, we will get
the same numbers in our Player. This is very useful for testing,
especially when playing against other Players which use randomness,
because we can replay previous test games with improved algorithms.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To make the above example (and many of the following examples) work, it
might be necessary to add appropriate imports to your python source file,
for example:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pelita.player</span> <span class="kn">import</span> <span class="n">AbstractPlayer</span>
<span class="kn">from</span> <span class="nn">pelita.datamodel</span> <span class="kn">import</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">stop</span>
</pre></div>
</div>
</div>
<p>Here we can see the first convenience property <tt class="docutils literal"><span class="pre">legal_moves</span></tt> which returns a
dictionary mapping move tuples to position tuples. The random player simply
selects a move at random from the keys (moves) of this dictionary and then
moves there. <tt class="docutils literal"><span class="pre">legal_moves</span></tt> always includes stop.</p>
<p>The next example is the not-quite random player
<tt class="docutils literal"><span class="pre">pelita.player.NQRandomPlayer</span></tt>.  This one does not move back to the position
where it was on its last turn and never stops in place:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NQRandomPlayer</span><span class="p">(</span><span class="n">AbstractPlayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Not-Quite-RandomPlayer that will move randomly but not stop or reverse. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_move</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">legal_moves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legal_moves</span>
        <span class="c"># Remove stop</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">legal_moves</span><span class="p">[</span><span class="n">datamodel</span><span class="o">.</span><span class="n">stop</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c"># now remove the move that would lead to the previous_position</span>
        <span class="c"># unless there is no where else to go.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">legal_moves</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">legal_moves</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_pos</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">del</span> <span class="n">legal_moves</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="c"># just in case, there is really no way to go to:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">legal_moves</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datamodel</span><span class="o">.</span><span class="n">stop</span>
        <span class="c"># and select a move at random</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnd</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">legal_moves</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
<p>Here we can see the use of another convenience method: <tt class="docutils literal"><span class="pre">previous_pos</span></tt> which
gives the position the bot had in the previous round.</p>
</div>
<div class="section" id="the-maze-coordinate-system">
<h2>The Maze Coordinate System<a class="headerlink" href="#the-maze-coordinate-system" title="Permalink to this headline">¶</a></h2>
<p>The coordinate system is the standard coordinate system used in computer games.
<tt class="docutils literal"><span class="pre">x</span></tt> increases to the left, and <tt class="docutils literal"><span class="pre">y</span></tt> increases downwards, and a position is
encoded as the tuple <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt>. There are no negative coordinates. The
following example illustrates this for a few positions:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>(0, 0)</td>
<td>(1, 0)</td>
<td>(2, 0)</td>
<td>(3, 0)</td>
<td>...</td>
</tr>
<tr class="row-even"><td>(0, 1)</td>
<td>(1, 1)</td>
<td>(2, 1)</td>
<td>(3, 1)</td>
<td>...</td>
</tr>
<tr class="row-odd"><td>(0, 2)</td>
<td>(1, 2)</td>
<td>(2, 2)</td>
<td>(3, 2)</td>
<td>...</td>
</tr>
<tr class="row-even"><td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>As a result we obtain the following direction vectors:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">north</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">south</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">west</span>  <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">east</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">stop</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="distances-in-the-maze">
<h3>Distances in the Maze<a class="headerlink" href="#distances-in-the-maze" title="Permalink to this headline">¶</a></h3>
<p>There are different ways of measuring distances between objects in the maze.
The <a class="reference external" href="http://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a>
is the length of the vector connecting the centers
of the cells where the objects are located:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/distance_euclidean.png"><img alt="Euclidean distance." src="_images/distance_euclidean.png" style="width: 300px;" /></a>
<p class="caption"><strong>Euclidean distance:</strong> The Euclidean distance between the two bots is
sqrt((x1-x2)**2 + (y1-y2)**2) = sqrt((4.5-2.5)**2+(0.5-1.5)**2) = 2.236...</p>
</div>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a>,
also known as L1-distance or taxicab-distance, is the
absolute difference of the coordinates of the two objects:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/distance_manhattan.png"><img alt="Manhattan distance." src="_images/distance_manhattan.png" style="width: 300px;" /></a>
<p class="caption"><strong>Manhattan distance:</strong> The Manhattan distance between the two bots is
abs(x1-x2) + abs(y1-y2) = abs(4-2) + abs(0-1) = 3</p>
</div>
<p>The maze distance counts the number of cells of the shortest path that
connects the two objects:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/distance_maze.png"><img alt="Maze distance." src="_images/distance_maze.png" style="width: 300px;" /></a>
<p class="caption"><strong>Maze distance:</strong> The Maze distance between the two bots is 5.</p>
</div>
<p>Note that Manhattan and maze distances are always integer values.
In the game, distances are almost always measured either in Manhattan or in
maze distance.
We provide a series of convenience methods for dealing with position
and distances in <a class="reference internal" href="pelita/pelita.graph.html#module-pelita.graph" title="pelita.graph"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.graph</span></tt></a>:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="pelita/pelita.graph.new_pos.html#pelita.graph.new_pos" title="pelita.graph.new_pos"><tt class="xref py py-obj docutils literal"><span class="pre">new_pos</span></tt></a></td>
<td>Adds a position tuple and a move tuple.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="pelita/pelita.graph.diff_pos.html#pelita.graph.diff_pos" title="pelita.graph.diff_pos"><tt class="xref py py-obj docutils literal"><span class="pre">diff_pos</span></tt></a></td>
<td>Return the move required to move from one position to another.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="pelita/pelita.graph.manhattan_dist.html#pelita.graph.manhattan_dist" title="pelita.graph.manhattan_dist"><tt class="xref py py-obj docutils literal"><span class="pre">manhattan_dist</span></tt></a></td>
<td>Manhattan distance between two points.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="a-basic-offensive-player">
<h2>A Basic Offensive Player<a class="headerlink" href="#a-basic-offensive-player" title="Permalink to this headline">¶</a></h2>
<p>A somewhat more elaborate example is the <tt class="xref py py-obj docutils literal"><span class="pre">pelita.player.BFSPlayer</span></tt> which uses
<em>breadth first search</em> on an <em>adjacency list</em> representation of the maze to
find food:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BFSPlayer</span><span class="p">(</span><span class="n">AbstractPlayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This player uses breadth first search to always go to the closest food.</span>

<span class="sd">    This player uses an adjacency list [1] to store the topology of the</span>
<span class="sd">    maze. It will then do a breadth first search [2] to search for the</span>
<span class="sd">    closest food. When found, it will follow the determined path until it</span>
<span class="sd">    reaches the food. This continues until all food has been eaten or the</span>
<span class="sd">    enemy wins.</span>

<span class="sd">    The adjacency lits representation (AdjacencyList) and breadth first search</span>
<span class="sd">    (AdjacencyList.bfs) are imported from pelita.graph.</span>

<span class="sd">    * [1] http://en.wikipedia.org/wiki/Adjacency_list</span>
<span class="sd">    * [2] http://en.wikipedia.org/wiki/Breadth-first_search</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">set_initial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Before the game starts we initialise our adjacency list.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span> <span class="o">=</span> <span class="n">AdjacencyList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_uni</span><span class="o">.</span><span class="n">reachable</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_pos</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bfs_food</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">bfs_food</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Breadth first search for food.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        path : a list of tuples (int, int)</span>
<span class="sd">            The positions (x, y) in the path from the current position to the</span>
<span class="sd">            closest food. The first element is the final destination.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enemy_food</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoPathException</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_move</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_pos</span><span class="p">:</span>
            <span class="c"># we have probably been killed</span>
            <span class="c"># reset the path</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_path</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bfs_food</span><span class="p">()</span>
        <span class="n">new_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">move</span> <span class="o">=</span> <span class="n">diff_pos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">new_pos</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">move</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legal_moves</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">move</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Whoops. We’re lost.</span>
            <span class="c"># If there was a timeout, and we are no longer where we think we</span>
            <span class="c"># were, calculate a new path.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_path</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_move</span><span class="p">()</span>
</pre></div>
</div>
<p>This next sections will explore the convenience properties of the
<tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt> as used in the <tt class="docutils literal"><span class="pre">BFSPlayer</span></tt>.</p>
<div class="section" id="current-uni-current-state-current-pos-and-enemy-food">
<h3><tt class="docutils literal"><span class="pre">current_uni</span></tt>, <tt class="docutils literal"><span class="pre">current_state</span></tt>, <tt class="docutils literal"><span class="pre">current_pos</span></tt> and <tt class="docutils literal"><span class="pre">enemy_food</span></tt><a class="headerlink" href="#current-uni-current-state-current-pos-and-enemy-food" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">BFSPlayer</span></tt> makes use of some more advanced concepts. The first thing to
note is that any player can override the method <tt class="docutils literal"><span class="pre">set_initial()</span></tt>. At this
stage food is still present, and all bots are at their initial position. In the
above example we initialise the adjacency list representation of the maze. As
mentioned previously the current state of the universe is always available as
<tt class="docutils literal"><span class="pre">current_uni</span></tt>. Within <tt class="docutils literal"><span class="pre">set_initial()</span></tt> this is the starting state.</p>
<p>In order to fill the adjacency list with entries, we make use of the helper
method <tt class="docutils literal"><span class="pre">CTFUniverse.reachable</span></tt>, which iterates through all positions that are
reachable from set of initial positions. This ensures that we only deal with
positions that we can actually move to.</p>
<p>Additionally, there is a low-level dict which includes all other game related
information: <tt class="docutils literal"><span class="pre">current_state</span></tt>. <tt class="docutils literal"><span class="pre">current_state</span></tt> is the current copy of the
internal <tt class="docutils literal"><span class="pre">GameMaster.game_state</span></tt> dict. It holds for example the current round
index or which bot is currently playing or how many timeouts each team has
produced. Some of these values have dedicated properties in <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt>
but some are only accessible via <tt class="docutils literal"><span class="pre">current_state</span></tt>. In some special cases
however, one might want to access the full state of the game. (Minus the
information the current Player is not allowed to access, of course.)
The dict is documented in-line in <tt class="docutils literal"><span class="pre">pelita/game_state.py</span></tt>.</p>
<p>The next interesting thing to look at is the <tt class="docutils literal"><span class="pre">bfs_food()</span></tt> method which simply
searches the <tt class="docutils literal"><span class="pre">AdjacencyList</span></tt> to find the closest food and returns a path to
that food. In the process it makes use of two convenience properties:
<tt class="docutils literal"><span class="pre">current_pos</span></tt> and <tt class="docutils literal"><span class="pre">enemy_food</span></tt>. The first is the location of the <tt class="docutils literal"><span class="pre">Bot</span></tt>
controlled by this <tt class="docutils literal"><span class="pre">Player</span></tt> as a position tuple. The second is a list of
position tuples of the food owned by the enemy (which can be eaten by this
bot).</p>
<p>There are a few more convenience properties available from <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt>,
you should look at the section <a class="reference internal" href="user-api.html#user-api-reference"><em>User API Reference</em></a> for details.</p>
</div>
<div class="section" id="recovery-strategies-in-case-of-death-or-timeout">
<h3>Recovery Strategies in Case of Death or Timeout<a class="headerlink" href="#recovery-strategies-in-case-of-death-or-timeout" title="Permalink to this headline">¶</a></h3>
<p>Lastly, we are going to see some error recovery code in the
<tt class="docutils literal"><span class="pre">get_move()</span></tt> method of the <tt class="docutils literal"><span class="pre">BFSPlayer</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">BFSPlayer</span></tt> is sometimes killed, as expected for an offensive player. In
order to detect this, it&#8217;s best to compare the current position with its
initial position using the <tt class="docutils literal"><span class="pre">initial_pos</span></tt> convenience property, since this is
where it will respawn. Alternatively, it is also possible to keep track of the
timeouts using <tt class="docutils literal"><span class="pre">self.current_state[&quot;timeout_teams&quot;]</span></tt>, which holds the
number of timeouts each team has already used up.</p>
<p>Your player only has a limited time to return from <tt class="docutils literal"><span class="pre">get_move()</span></tt>. The default
is approximately three seconds. If your player does not respond in time, the
<tt class="docutils literal"><span class="pre">GameMaster</span></tt> will move the bot at random for this turn. It&#8217;s important to
recover from such an event. The <tt class="docutils literal"><span class="pre">BFSPlayer</span></tt> does this by catching the
<tt class="docutils literal"><span class="pre">ValueError</span></tt> raised by <tt class="docutils literal"><span class="pre">diff_pos</span></tt>.</p>
<p>The main problem with detecting a timeout is that, as long as your
computationally expensive process is running, there is no way to interrupt it.
Imagine an infinite <tt class="docutils literal"><span class="pre">for</span></tt> loop in your <tt class="docutils literal"><span class="pre">get_move()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>In this case, your <tt class="docutils literal"><span class="pre">get_move()</span></tt> will be executed exactly once! Thus it is
important to ensure that your search algorithms are efficient and fast.</p>
<p>For convenience <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt> has a <tt class="docutils literal"><span class="pre">time_spent()</span></tt> method, which
shows the approximate time since <tt class="docutils literal"><span class="pre">get_move()</span></tt> has been called. A simple
approach using this method could be as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_move</span><span class="p">():</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">best_move</span> <span class="o">=</span> <span class="n">stop</span>
    <span class="n">MAX_TIME</span> <span class="o">=</span> <span class="mi">3</span> <span class="c"># whatever the rules tell you</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_spent</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">MAX_TIME</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_move</span>
    <span class="c"># do some iterative data mining and eventually</span>
    <span class="c"># change the value of self.best_move</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">do_first_calculation</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_spent</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">MAX_TIME</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_move</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">do_second_calculation</span><span class="p">()</span>
    <span class="c"># ...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Even though <tt class="docutils literal"><span class="pre">time_spent()</span></tt> takes into account the initial calculations
done in <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt>, it knows nothing about network delays.
Therefore, it seems adviseable not to wait until the last millisecond
before returning.</p>
</div>
<p>A very important thing to emphasise is the following: When one bot blocks,
the whole team blocks. This means that all subsequent calls to <tt class="docutils literal"><span class="pre">get_move()</span></tt>
for a team are stalled until the blocking <tt class="docutils literal"><span class="pre">get_move()</span></tt> has finished.</p>
<p>This also means, that it may happen that the second call to <tt class="docutils literal"><span class="pre">get_move()</span></tt>
is already behind in terms of time when it is being executed. In extreme
cases, it may even generate a second timeout <em>before</em> its execution.</p>
<p>There is no good way to predict this other than keeping track of one’s
own execution time and returning early, if necessary. For long lasting
tasks, it may be a good idea to experiment with concurrency.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>A remark on timeout handling during the <tt class="docutils literal"><span class="pre">set_initial()</span></tt> phase.</p>
<p class="last">Sometimes, it may seem a good idea to do some pre-calculations during the
<tt class="docutils literal"><span class="pre">set_initial</span></tt> phase. We like to enforce this by also giving each Player
some extra time. There is no strict limit, but after three seconds, the
<tt class="docutils literal"><span class="pre">GameMaster</span></tt> is going to move on with its duty. Just make sure you’ll be
ready when you receive the first <tt class="docutils literal"><span class="pre">get_move()</span></tt> call.</p>
</div>
</div>
</div>
<div class="section" id="interacting-with-the-maze">
<h2>Interacting with the Maze<a class="headerlink" href="#interacting-with-the-maze" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">BFSPlayer</span></tt> above uses the adjacency list representation provided by:
<tt class="docutils literal"><span class="pre">pelita.graph.AdjacencyList</span></tt>. Let&#8217;s have a quick look at how this is
generated, in case you would like to implement your own <a class="reference external" href="http://en.wikipedia.org/wiki/Graph_(data_structure)">graph storage</a> or leverage an
alternative existing package such as <a class="reference external" href="http://networkx.lanl.gov/">NetworkX</a>.</p>
<p>Here it is the <tt class="docutils literal"><span class="pre">__init__</span></tt> of the <tt class="docutils literal"><span class="pre">AdjacencyList</span></tt>:</p>
<div class="highlight-python"><pre>    ----------
    position : tuple of int (x, y)
        current position

    move : tuple of int (x, y)
        direction vector

    Returns
    -------
    new_pos : tuple of int (x, y)
        new position coordinates

    """
    pos_x = position[0] + move[0]
</pre>
</div>
<p>In order to obtain the positions of all free spaces, the
<a class="reference internal" href="pelita/pelita.datamodel.Maze.html#pelita.datamodel.Maze" title="pelita.datamodel.Maze"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.datamodel.Maze</span></tt></a> class provides the function
<a class="reference internal" href="pelita/pelita.datamodel.Maze.pos_of.html#pelita.datamodel.Maze.pos_of" title="pelita.datamodel.Maze.pos_of"><tt class="xref py py-obj docutils literal"><span class="pre">pelita.datamodel.Maze.pos_of</span></tt></a>. A maze can hold three different components at
each position, all of them available in <tt class="docutils literal"><span class="pre">pelita.datamodel</span></tt>: <tt class="docutils literal"><span class="pre">Wall</span></tt>,
<tt class="docutils literal"><span class="pre">Free</span></tt>, <tt class="docutils literal"><span class="pre">Food</span></tt>. We thus can get a list of all positions by calling:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">maze</span><span class="o">.</span><span class="n">pos_of</span><span class="p">(</span><span class="n">Free</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we use the method <tt class="docutils literal"><span class="pre">legal_moves(pos).values()</span></tt> to obtain the adjacent
free spaces, for each of the free positions.  The last step is to use the
<tt class="docutils literal"><span class="pre">update</span></tt> method to set the generated dictionary, which we can do, since
<tt class="docutils literal"><span class="pre">AdjacencyList</span></tt> inherits from <tt class="docutils literal"><span class="pre">dict</span></tt>.</p>
<p>In addition to <tt class="docutils literal"><span class="pre">pos_of</span></tt>, there are a few additional constructs that are
useful when dealing with the maze. The property <tt class="docutils literal"><span class="pre">positions</span></tt> gives all the
positions in the maze. To check if a given maze component is at a certain
position use the <tt class="docutils literal"><span class="pre">in</span></tt> operator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Free</span> <span class="ow">in</span> <span class="n">maze</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Sometimes, when exploring future states of the universe, you may want to add or
remove food to the maze:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># removing items</span>
<span class="n">maze</span><span class="o">.</span><span class="n">remove_at</span><span class="p">(</span><span class="n">Food</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c"># adding items</span>
<span class="n">stuff</span> <span class="o">=</span> <span class="n">maze</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">stuff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Food</span><span class="p">)</span>
<span class="n">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stuff</span>
</pre></div>
</div>
</div>
<div class="section" id="a-basic-defensive-player">
<h2>A Basic Defensive Player<a class="headerlink" href="#a-basic-defensive-player" title="Permalink to this headline">¶</a></h2>
<p>As a defensive example we have the <tt class="docutils literal"><span class="pre">BasicDefensePlayer</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BasicDefensePlayer</span><span class="p">(</span><span class="n">AbstractPlayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A crude defensive player.</span>

<span class="sd">    Will move towards the border, and as soon as it notices enemies in its</span>
<span class="sd">    territory, it will start to track them. When it kills the enemy it returns</span>
<span class="sd">    to the border and waits there for more. Like the BFSPlayer this player</span>
<span class="sd">    stores the maze as an adjacency list [1] but uses the breadth first search [2] to</span>
<span class="sd">    find the closest position on the border.  However it additionally uses the</span>
<span class="sd">    A* (A Star) search [3] to find the shortest path to its target.</span>

<span class="sd">    The adjacency lits representation (AdjacencyList) and A* search</span>
<span class="sd">    (AdjacencyList.a_star) are imported from pelita.graph.</span>

<span class="sd">    * [1] http://en.wikipedia.org/wiki/Adjacency_list</span>
<span class="sd">    * [2] http://en.wikipedia.org/wiki/Breadth-first_search</span>
<span class="sd">    * [3] http://en.wikipedia.org/wiki/A*_search_algorithm</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">set_initial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span> <span class="o">=</span> <span class="n">AdjacencyList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_uni</span><span class="o">.</span><span class="n">reachable</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_pos</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_to_border</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracking_idx</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">path_to_border</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Path to the closest border position. &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">team_border</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoPathException</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">path_to_target</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Path to the target we are currently tracking. &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span><span class="o">.</span><span class="n">a_star</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tracking_target</span><span class="o">.</span><span class="n">current_pos</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoPathException</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tracking_target</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Bot object we are currently tracking. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_uni</span><span class="o">.</span><span class="n">bots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tracking_idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_move</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># if we were killed, for whatever reason, reset the path</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_pos</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_to_border</span>

        <span class="c"># First we need to check, if our tracked enemy is still</span>
        <span class="c"># in our zone</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracking_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># if the enemy is no longer in our zone</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">team</span><span class="o">.</span><span class="n">in_zone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracking_target</span><span class="o">.</span><span class="n">current_pos</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracking_idx</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_to_border</span>
            <span class="c"># otherwise update the path to the target</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_to_target</span>

        <span class="c"># if we are not currently tracking anything</span>
        <span class="c"># (need to check explicity for None, because using &#39;if </span>
        <span class="c"># self.tracking_idx&#39; would evaluate to True also when we are tracking</span>
        <span class="c"># the bot with index == 0)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracking_idx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># check the enemy positions</span>
            <span class="n">possible_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">enemy</span> <span class="k">for</span> <span class="n">enemy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">enemy_bots</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">team</span><span class="o">.</span><span class="n">in_zone</span><span class="p">(</span><span class="n">enemy</span><span class="o">.</span><span class="n">current_pos</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">possible_targets</span><span class="p">:</span>
                <span class="c"># get the path to the closest one</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">possible_paths</span> <span class="o">=</span> <span class="p">[(</span><span class="n">enemy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span><span class="o">.</span><span class="n">a_star</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">enemy</span><span class="o">.</span><span class="n">current_pos</span><span class="p">))</span>
                                      <span class="k">for</span> <span class="n">enemy</span> <span class="ow">in</span> <span class="n">possible_targets</span><span class="p">]</span>
                <span class="k">except</span> <span class="n">NoPathException</span><span class="p">:</span>
                    <span class="n">possible_paths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">possible_paths</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">possible_paths</span><span class="p">:</span>
                <span class="n">closest_enemy</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">possible_paths</span><span class="p">,</span>
                                          <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">enemy_path</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">enemy_path</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

                <span class="c"># track that bot by using its index</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracking_idx</span> <span class="o">=</span> <span class="n">closest_enemy</span><span class="o">.</span><span class="n">index</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># otherwise keep going if we aren&#39;t already underway</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_to_border</span>

        <span class="c"># if something above went wrong, just stand still</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datamodel</span><span class="o">.</span><span class="n">stop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">diff_pos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
</pre></div>
</div>
<p>Defense is important because your enemy is awarded <tt class="docutils literal"><span class="pre">5</span></tt> points if he
manages to destroy one of your bots!</p>
<p>The player mostly uses convenience properties already introduced for the
<tt class="docutils literal"><span class="pre">BFSPlayer</span></tt> in addition to a few others. For example <tt class="docutils literal"><span class="pre">path_to_border</span></tt> uses
the <tt class="docutils literal"><span class="pre">team_border</span></tt> convenience property which gives the positions of the
border. Also, <tt class="docutils literal"><span class="pre">get_move()</span></tt> access the <tt class="docutils literal"><span class="pre">enemy_bots</span></tt> property and then uses
the <tt class="docutils literal"><span class="pre">team.in_zone(position)</span></tt> function to check if an enemy position is within
the zone of this team. Note that <tt class="docutils literal"><span class="pre">team</span></tt> is a convenience property of the
<tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt> which in turn gives access to the <tt class="docutils literal"><span class="pre">Team</span></tt> instance from the
<tt class="docutils literal"><span class="pre">CTFUniverse</span></tt>, which in turn has the method <tt class="docutils literal"><span class="pre">in_zone(position)</span></tt>.</p>
<p>For a comprehensive overview of all the properties of <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt>,
look at the section <a class="reference internal" href="user-api.html#user-api-reference"><em>User API Reference</em></a>.</p>
<p>Note that this player simply ignores the noisy enemy positions (described
next).</p>
</div>
<div class="section" id="noisy-enemy-positions">
<h2>Noisy Enemy Positions<a class="headerlink" href="#noisy-enemy-positions" title="Permalink to this headline">¶</a></h2>
<p>In general, the <tt class="docutils literal"><span class="pre">CTFUniverse</span></tt> you receive is noisy. This means that you can
only obtain an accurate fix on the enemy bots if they are within 5 squares maze
distance (otherwise, the position is noisy with a uniform radius of 5 squares
maze distance). These two values may lead to confusing values: for example if
the bot is 6 squares away, but the added noise of 4 squares towards your bot,
make it appear as if it were only 2 squares away. Thus, you can check if a bot
position is noisy using the <tt class="docutils literal"><span class="pre">noisy</span></tt> attribute of the bot instance, in
combination with the <tt class="docutils literal"><span class="pre">enemy_bots</span></tt> convenience property provided by
<tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">enemy_bots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">noisy</span>
</pre></div>
</div>
<p>One idea is to implement probabilistic tracking using a <a class="reference external" href="http://en.wikipedia.org/wiki/Kalman_filter">Kalman filter</a></p>
<p>If you wish to know how the noise is implemented, look at the class:
<tt class="docutils literal"><span class="pre">pelita.game_master.UniverseNoiser</span></tt>.</p>
</div>
<div class="section" id="implementation-details-of-convenience-properties">
<h2>Implementation Details of Convenience Properties<a class="headerlink" href="#implementation-details-of-convenience-properties" title="Permalink to this headline">¶</a></h2>
<p>This section contains some details about the implementation of the convenience
properties of <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt>. Reading this section is not required, but may
be of interest to the curious reader.</p>
<p>Let&#8217;s take a quick look as the implementation
of <tt class="docutils literal"><span class="pre">current_uni</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">current_uni</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The current Universe.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        universe : Universe</span>
<span class="sd">            the current Universe</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe_states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Importantly we see that the <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt> automatically maintains a stack
of previous states of the Universe called <tt class="docutils literal"><span class="pre">universe_states</span></tt>.
As we can see <tt class="docutils literal"><span class="pre">current_uni</span></tt> is simply the top element of this stack. This
allows us to access the properties and methods of the <tt class="docutils literal"><span class="pre">CTFUniverse</span></tt>, for
example look at the implementation of <tt class="docutils literal"><span class="pre">legal_moves</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">legal_moves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The currently possible moves, and where they lead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        legal_moves : dict mapping moves to positions</span>
<span class="sd">            the currently legal moves</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_uni</span><span class="o">.</span><span class="n">legal_moves</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pos</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we can see that this simply calls the method <tt class="docutils literal"><span class="pre">legal_moves(pos)</span></tt>
which is provided by <tt class="docutils literal"><span class="pre">CTFUniverse</span></tt>. We also see one of the convenience
properties used in the <tt class="docutils literal"><span class="pre">bfs_food()</span></tt> method: <tt class="docutils literal"><span class="pre">current_pos</span></tt> which returns the
current position of the bot.  Let&#8217;s have a look at this:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">current_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The current position of this bot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        current_pos : tuple of (int, int)</span>
<span class="sd">            the current position (x, y) of this bot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">me</span><span class="o">.</span><span class="n">current_pos</span>
</pre></div>
</div>
<p>We see that this makes use of the <tt class="docutils literal"><span class="pre">me</span></tt> property which is defined as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">me</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The Bot object this Player controls.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        me : Bot</span>
<span class="sd">            the bot controlled by this player</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_uni</span><span class="o">.</span><span class="n">bots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span>
</pre></div>
</div>
<p>As you can see, <tt class="docutils literal"><span class="pre">me</span></tt> will simply obtain the <tt class="docutils literal"><span class="pre">Bot</span></tt> instance controlled by
this player from the current universe using the hidden <tt class="docutils literal"><span class="pre">_index</span></tt> attribute of
the player. In practice, you should be able to avoid having to use the
<tt class="docutils literal"><span class="pre">_index</span></tt> directly but it&#8217;s good to know how this is implemented in case you
wish to do something exotic.</p>
<p>Lets now have a look at the convenience property <tt class="docutils literal"><span class="pre">enemy_food</span></tt> Again, this is
simply forwarded to the <tt class="docutils literal"><span class="pre">CTFUniverse</span></tt> using <tt class="docutils literal"><span class="pre">current_uni</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">enemy_food</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Food owned by the enemy which can be eaten by this Player&#39;s bot.</span>

<span class="sd">        Please note that it is valid for this list to be empty during get_move.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        enemy_food : list of position tuples (int, int)</span>
<span class="sd">            The positions (x, y) of edible food</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_uni</span><span class="o">.</span><span class="n">enemy_food</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">me</span><span class="o">.</span><span class="n">team_index</span><span class="p">)</span>
</pre></div>
</div>
<p>As with <tt class="docutils literal"><span class="pre">legal_moves</span></tt>, a method from <tt class="docutils literal"><span class="pre">CTFUniverse</span></tt> is called, namely
<tt class="docutils literal"><span class="pre">enemy_food</span></tt>. However, we need to tell it which team we are on. This is
obtained using the <tt class="docutils literal"><span class="pre">me</span></tt> property to access the controlled <tt class="docutils literal"><span class="pre">Bot</span></tt> instance,
which in turn stores the <tt class="docutils literal"><span class="pre">team_index</span></tt>. In practice, the information stored in
the <tt class="docutils literal"><span class="pre">CTFUniverse</span></tt> should be accessible through the convenience properties of
the <tt class="docutils literal"><span class="pre">AbstractPlayer</span></tt>. However, if these do not suffice, please have a look
at the source code.</p>
<p>Now that you know about <tt class="docutils literal"><span class="pre">universe_states</span></tt>, <tt class="docutils literal"><span class="pre">_index</span></tt> and <tt class="docutils literal"><span class="pre">current_pos</span></tt>
let&#8217;s have a look at how the <tt class="docutils literal"><span class="pre">previous_pos</span></tt> property (used in the
<tt class="docutils literal"><span class="pre">NQRandomPlayer</span></tt>) is implemented:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">previous_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The previous position of the bot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        previous_pos : tuple of (int, int)</span>
<span class="sd">            the previous position (x, y) of this bot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe_states</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span><span class="o">.</span><span class="n">current_pos</span>
</pre></div>
</div>
<p>Again, we will make use of <tt class="docutils literal"><span class="pre">universe_states</span></tt>, but this time we will look at
the second element from the top of the stack. The <tt class="docutils literal"><span class="pre">CTFUniverse</span></tt> maintains a
list of bots <tt class="docutils literal"><span class="pre">bots</span></tt> and the hidden attribute <tt class="docutils literal"><span class="pre">_index</span></tt> can be used to obtain
the respective bot instance controlled by the player. Lastly, we simply look at
the <tt class="docutils literal"><span class="pre">current_pos</span></tt> property of the bot (the bot instance from one turn ago) to
obtain its previous position.</p>
<p>The <tt class="docutils literal"><span class="pre">team</span></tt> property uses the <tt class="docutils literal"><span class="pre">me</span></tt> property to access the bots
<tt class="docutils literal"><span class="pre">team_index</span></tt> which it then uses in <tt class="docutils literal"><span class="pre">current_uni.teams</span></tt> to get the
respective <tt class="docutils literal"><span class="pre">Team</span></tt> instance:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">team</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The Team object this Player&#39;s Bot is on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        team : Team</span>
<span class="sd">            the team of the bot controlled by this player</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_uni</span><span class="o">.</span><span class="n">teams</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">me</span><span class="o">.</span><span class="n">team_index</span><span class="p">]</span>
</pre></div>
</div>
<p>Something similar is achieved for the <tt class="docutils literal"><span class="pre">team_border</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">team_border</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Positions of the border positions.</span>
<span class="sd">        These are the last positions in the zone of the team.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        team_border : list of tuple of (int, int)</span>
<span class="sd">            the border positions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_uni</span><span class="o">.</span><span class="n">team_border</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">me</span><span class="o">.</span><span class="n">team_index</span><span class="p">)</span>
</pre></div>
</div>
<p>And again for <tt class="docutils literal"><span class="pre">enemy_bots</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">enemy_bots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A list of enemy Bots.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        enemy_bots : list of Bot objects</span>
<span class="sd">            all Bots on all enemy teams</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_uni</span><span class="o">.</span><span class="n">enemy_bots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">me</span><span class="o">.</span><span class="n">team_index</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2011–2013, Valentin Haenel, Rike-Benjamin Schuppner et. al..<br/>
      Last updated on Aug 29, 2013.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2b1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>