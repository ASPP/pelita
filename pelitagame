#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function

import argparse
import contextlib
import json
import logging
import random
import time

import pelita
from pelita.libpelita import *

# silence stupid warnings from logging module
logging.root.manager.emittedNoHandlerWarning = 1
_logger = logging.getLogger("pelitagame")

class ReplayPublisher(object):
    def __init__(self, publish_sock, replayfile):
        with open(replayfile) as f:
            self.old_game = f.read().split("\x04")

        self.publisher = pelita.simplesetup.SimplePublisher(publish_sock)

    def run(self):
        for state in self.old_game:
            if state:
                message = json.loads(state)
                self.publisher._send(message)

class ResultPrinter(pelita.viewer.AbstractViewer):
    def __init__(self, parseable_output):
        self.parseable_output = parseable_output

    def observe(self, universe, game_state):
        self.print_bad_bot_status(universe, game_state)
        if game_state["finished"]:
            self.print_possible_winner(universe, game_state)

    def print_bad_bot_status(self, universe, game_state):
        for bot_id, reason in game_state["bot_error"].items():
            if reason == "timeout":
                sys.stderr.write("Timeout #%r for team %r (bot index %r).\n" % (
                                  game_state["timeout_teams"][universe.bots[bot_id].team_index],
                                  universe.bots[bot_id].team_index,
                                  bot_id))

            else:
                sys.stderr.write("Problem for team %r (bot index %r) (%s).\n" % (
                                  universe.bots[bot_id].team_index,
                                  bot_id,
                                  reason))

        for team_id, reason in enumerate(game_state["teams_disqualified"]):
            if reason == "timeout":
                sys.stderr.write("Team %r had too many timeouts. Team disqualified.\n" % team_id)
            elif reason == "disconnected":
                sys.stderr.write("Team %r disconnected. Team disqualified.\n" % team_id)
            elif reason is not None:
                sys.stderr.write("Team %r disqualified (%r).\n" % (team_id, reason))


    def print_possible_winner(self, universe, game_state):
        """ Checks the event list for a potential winner and prints this information.

        This is needed for scripts parsing the output.
        """
        winning_team = game_state.get("team_wins")
        if winning_team is not None:
            winner = universe.teams[winning_team]
            winner_name = game_state["team_name"][winner.index]
            loser = universe.enemy_team(winning_team)
            loser_name = game_state["team_name"][loser.index]
            msg = "Finished. '%s' won over '%s'. (%r:%r)" % (
                    winner_name, loser_name,
                    winner.score, loser.score
                )
            if self.parseable_output:
                msg += '\n' + str(winner.index)
            sys.stdout.flush()
        elif game_state.get("game_draw") is not None:
            t0 = universe.teams[0]
            t0_name = game_state["team_name"][t0.index]
            t1 = universe.teams[1]
            t1_name = game_state["team_name"][t1.index]
            msg = "Finished. '%s' and '%s' had a draw. (%r:%r)" % (
                    t0_name, t1_name,
                    t0.score, t1.score
                )
            if self.parseable_output:
                msg += "\n-"
        else:
            return

        print(msg)
        # We must manually flush, else our forceful stopping of Tk
        # won't let us pipe it.
        sys.stdout.flush()

def run_external_viewer(subscribe_sock, controller, geometry, delay):
    # Something on OS X prevents Tk from running in a forked process.
    # Therefore we cannot use multiprocessing here. subprocess works, though.
    viewer_args = [ str(subscribe_sock) ]
    if controller:
        viewer_args += ["--controller-address", str(controller)]
    if geometry:
        viewer_args += ["--geometry", "{0}x{1}".format(*geometry)]
    if delay:
        viewer_args += ["--delay", str(delay)]

    tkviewer = os.path.join(os.path.dirname(sys.argv[0]), "tkviewer.py")
    external_call = [get_python_process(), tkviewer] + viewer_args
    _logger.debug("Executing: %r", external_call)
    return subprocess.Popen(external_call)


def strip_module_prefix(module):
    if "@" in module:
        try:
            prefix, module = module.split("@")
            return ModuleSpec(prefix=prefix, module=module)
        except ValueError:
            raise ValueError("Bad module definition: {}.".format(module))
    else:
        return ModuleSpec(prefix=None, module=module)

def prepare_team(team_spec):
    # check if we've been given an address which a remote
    # player wants to connect to
    if "://" in team_spec:
        module = None
        address = team_spec
    else:
        module = strip_module_prefix(team_spec)
        address = "tcp://127.0.0.1"
    return TeamSpec(module, address)

def start_logging(filename):
    if filename:
        hdlr = logging.FileHandler(filename, mode='w')
    else:
        hdlr = logging.StreamHandler()
    logger = logging.getLogger('pelita')
    FORMAT = \
    '[%(relativeCreated)06d %(name)s:%(levelname).1s][%(funcName)s] %(message)s'
    formatter = logging.Formatter(FORMAT)
    hdlr.setFormatter(formatter)
    logger.addHandler(hdlr)
    logger.setLevel(logging.DEBUG)

def geometry_string(s):
    """Get a X-style geometry definition and return a tuple.

    600x400 -> (600,400)
    """
    try:
        x_string, y_string = s.split('x')
        geometry = (int(x_string), int(y_string))
    except ValueError:
        msg = "%s is not a valid geometry specification" %s
        raise argparse.ArgumentTypeError(msg)
    return geometry

@contextlib.contextmanager
def autoclose_externals(external_viewers, external_players):
    try:
        yield
    except KeyboardInterrupt:
        for external_viewer in external_viewers:
            external_viewer.kill()
    finally:
        # kill all client processes. NOW!
        # (is this too early?)
        for external_player in external_players:
            _logger.debug("Attempting to terminate %r.", external_player)
            external_player.terminate()
        for external_player in external_players:
            external_player.wait()
            _logger.debug("%r terminated.", external_player)

parser = argparse.ArgumentParser(description='Run a single pelita game',
                                 add_help=False,
                                 formatter_class=argparse.RawDescriptionHelpFormatter)
parser._positionals = parser.add_argument_group('Arguments')
parser.add_argument('team_specs', help='teams (default: random)', nargs='*', default=None)

parser._optionals = parser.add_argument_group('Options')
parser.add_argument('--help', '-h', help='show this help message and exit',
                    action='store_const', const=True)
parser.add_argument('--version', help='show the version number and exit',
                    action='store_const', const=True)
parser.add_argument('--log', help='print debugging log information to'
                                  ' LOGFILE (default \'stderr\')',
                    metavar='LOGFILE', default=argparse.SUPPRESS, nargs='?')
parser.add_argument('--dump', help='print game dumps to file (will be overwritten)'
                                  ' DUMPFILE (default \'pelita.dump\')',
                    metavar='DUMPFILE', default=argparse.SUPPRESS, nargs='?')
parser.add_argument('--replay', help='replay a dumped game'
                                  ' DUMPFILE (default \'pelita.dump\')',
                    metavar='DUMPFILE', default=argparse.SUPPRESS, nargs='?')
parser.add_argument('--rounds', type=int, default=300,
                    help='maximum number of rounds to play')
parser.add_argument('--fps', type=float, default=40,
                    help='(approximate) number of frames per second in a graphical viewer')
parser.add_argument('--seed', type=int, metavar='SEED', default=None,
                    help='fix random seed')
parser.add_argument('--geometry', type=geometry_string, metavar='NxM',
                    help='initial size of the game window')
parser.add_argument('--dry-run', const=True, action='store_const',
                    help='load players but do not actually play the game')
parser.add_argument('--max-timeouts', type=int, default=5,
                    dest='max_timeouts', help='maximum number of timeouts allowed (default: 5)')
parser.add_argument('--parseable-output', action="store_const", const=True,
                    help='Make game result parseable')
parser.add_argument('--list-teams', action="store_const", const=True,
                    help='Print the names of the included default teams.')
parser.add_argument('--check-team', action="store_const", const=True,
                    help='Check that the team is valid (on first sight) and print its name.')

timeout_opt = parser.add_mutually_exclusive_group()
timeout_opt.add_argument('--timeout', type=float, metavar="SEC",
                         dest='timeout_length', help='time before timeout is triggered (default: 3 seconds)')
timeout_opt.add_argument('--no-timeout', const=None, action='store_const',
                         dest='timeout_length', help='run game with no timeouts')
parser.set_defaults(timeout_length=3)

publisher_opt = parser.add_mutually_exclusive_group()
publisher_opt.add_argument('--publish', type=str, metavar='URL',
                           dest='publish_to', help='publish to this zmq socket')
publisher_opt.add_argument('--no-publish', const=False, action='store_const',
                           dest='publish_to', help='do not publish')
parser.set_defaults(publish_to="tcp://*:*")

controller_opt = parser.add_argument_group("Controller")
controller_opt.add_argument('--controller', type=str, metavar='URL', default="tcp://127.0.0.1:*",
                            help='open a controller on this zmq socket')
controller_opt.add_argument('--external-controller', const=True, action='store_const',
                            help='force control by an external controller')

viewer_opt = parser.add_mutually_exclusive_group()
viewer_opt.add_argument('--ascii', action='store_const', const='ascii',
                        dest='viewer', help='use the ASCII viewer')
viewer_opt.add_argument('--null', action='store_const', const='null',
                        dest='viewer', help='use the /dev/null viewer')
viewer_opt.add_argument('--progress', action='store_const', const='progress',
                        dest='viewer', help='use the progress viewer')
viewer_opt.add_argument('--tk', action='store_const', const='tk',
                        dest='viewer', help='use the tk viewer (default)')
viewer_opt.add_argument('--tk-no-sync', action='store_const', const='tk-no-sync',
                        dest='viewer', help='use the unsynchronised tk viewer')
parser.set_defaults(viewer='tk')

layout_opt = parser.add_mutually_exclusive_group()
layout_opt.add_argument('--layoutfile', metavar='FILE',
                        help='load a maze layout from FILE')
layout_opt.add_argument('--layout', metavar='NAME',
                        help="load a maze layout by name. If NAME is"
                        " 'list' return a list of available names")
layout_opt.add_argument('--filter', metavar='STRING',
                        default='normal_without_dead_ends',
                        help='retrict the pool of random layouts to those whose'
                        ' name contains STRING.'
                        ' Default: \'normal_without_dead_ends\'')

parser.epilog = """\
Team Specification:
  - Using predefined players:
    A single name (e.g. 'NQRandomPlayer') in which case the team is
    composed of players of this type, or a comma separated list of
    player types (e.g. 'BFSPlayer,BasicDefensePlayer'). Example usage:

        $ %(prog)s BFSPlayer,RandomPlayer NQRandomPlayer,BasicDefensePlayer

    Use --list-teams to get a list of predefined players.

  - Using custom players (filename):
    The name of a python file (e.g. '~/my_player.py') which defines
    a function named 'factory' (you can change the name of the factory
    function by adding ':my_factory' to the filename). The factory
    function must take no arguments and return an instance of
    pelita.player.SimpleTeam.
    Example implementation:

    def factory():
        return pelita.player.SimpleTeam("My Team", MyPlayer1(), MyPlayer2())

    Example usage:

        $ %(prog)s ~/my_player.py NQRandomPlayer,BasicDefensePlayer

    Example of custom factory function:

        $ %(prog)s ~/my_player.py:my_factory NQRandomPlayer,BasicDefensePlayer

  - Using custom players (package):
    The name of a python package (i.e. a directory with an __init__.py file),
    which exposes a function named 'factory' (see above for more details).
    Example usage:

        $ %(prog)s my_player NQRandomPlayer,BasicDefensePlayer

  - Using a different Python version:
    Additionally, player specifications may use a prefix (ending with @)
    to use a different executable for the subprocess.

        $ %(prog)s py3@my_new_player py2@my_old_player

    runs the first player with Python 3 and the second player with Python 2.
    A non-existing prefix is taken as ‘py@’ that is the very same Python version
    the pelitagame script is run with.

  - Using custom players (simpleclient):
    The address the server should bind on and wait for a client
    to connect to.

    Example of a server binding the left team to 'tcp://*:9005' and
    the right team to 'ipc:///tmp/mysocket':

        $ %(prog)s tcp://*:9005 ipc:///tmp/mysocket

    Example of a server binding the left team to 'tcp://*:9005' and
    using a built-in Player as the right team:

        $ %(prog)s tcp://*:9005 NQRandomPlayer,BasicDefensePlayer

Layout specification:
  If neither --layoutfile nor --layout are specified, the maze is
  chosen at random from the pool of available layouts.
  You can restrict this pool by using --filter.
"""

def run_game():

    config = {
        "publish-addr": None,
        "controller-addr": None,
        "viewers": [],
        "external-viewers": []
    }

    args = parser.parse_args()
    if args.help:
        parser.print_help()
        sys.exit(0)
    if args.version:
        print("Pelita %s" % pelita.version)
        sys.exit(0)
    if args.layout == 'list':
        layouts = pelita.layout.get_available_layouts()
        print('\n'.join(layouts))
        sys.exit(0)
    if args.seed is not None:
        random.seed(args.seed)
    if args.viewer.startswith('tk') and not args.publish_to:
        raise ValueError("Options --tk (or --tk-no-sync) and --no-publish are mutually exclusive.")

    try:
        start_logging(args.log)
    except AttributeError:
        pass

    if args.list_teams:
        from players import SANE_PLAYERS
        print('\n'.join(p.__name__ for p in SANE_PLAYERS))
        sys.exit(0)

    if args.check_team:
        if not args.team_specs:
            raise ValueError("No teams specified.")
        for team_spec in args.team_specs:
            team_name = check_team(prepare_team(team_spec))
            print("NAME:", team_name)
        sys.exit(0)

    try:
        # TODO: Re-include the dump.
        dump = args.dump or 'pelita.dump'
    except AttributeError:
        dump = None

    try:
        replayfile = args.replay or 'pelita.dump'
    except AttributeError:
        replayfile = None

    external_players = []
    external_viewers = []

    if replayfile:
        replay_publisher = ReplayPublisher(args.publish_to, replayfile)
        config["publish-addr"] = replay_publisher.publisher.socket_addr
        subscribe_sock = replay_publisher.publisher.socket_addr.replace('*', 'localhost')

        if args.viewer.startswith("tk"):
            args.viewer = "tk-no-sync"
        runner = replay_publisher.run
    else:
        if args.layout or args.layoutfile:
            layout_name, layout_string = pelita.layout.load_layout(layout_name=args.layout, layout_file=args.layoutfile)
        else:
            layout_name, layout_string = pelita.layout.get_random_layout(args.filter)
        print("Using layout '%s'" % layout_name)

        num_teams = 2
        team_specs = args.team_specs
        while len(team_specs) < num_teams:
            team_specs.append("random")
        if len(team_specs) > num_teams:
            raise RuntimeError("Too many teams given. Must be < {}.".format(num_teams))

        teams = [prepare_team(team_spec) for team_spec in team_specs]


        print(teams)

        if args.dry_run:
            sys.exit(0)

        if args.viewer == 'tk-no-sync':
            # only use delay when not synced.
            initial_delay = 0.5
        else:
            initial_delay = 0.0

        server = pelita.simplesetup.SimpleServer(layout_string=layout_string,
                                                 rounds=args.rounds,
                                                 bind_addrs=[team.address for team in teams],
                                                 initial_delay=initial_delay,
                                                 max_timeouts=args.max_timeouts,
                                                 timeout_length=args.timeout_length,
                                                 layout_name=layout_name,
                                                 seed=args.seed)

        # Update our teams with the bound addresses
        teams = [
            team._replace(address=address)
            for team, address in zip(teams, server.bind_addresses)
        ]

        for idx, team in enumerate(teams):
            if team.module is None:
                print("Waiting for external team %d to connect to %s." % (idx, team.address))

        external_players = [
            call_standalone_pelitagame(team.module, team.address)
            for team in teams
            if team.module
        ]

       # print([sub.returncode for sub in subs])
        #[s.wait() for s in subs]

        # register the viewers
        if args.publish_to:
            publisher = pelita.simplesetup.SimplePublisher(args.publish_to)
            config["publish-addr"] = publisher.socket_addr
            print("Publishing to %s" % publisher.socket_addr)
            server.game_master.register_viewer(publisher)

        if dump:
            server.game_master.register_viewer(pelita.viewer.DumpingViewer(open(dump, "w")))
        if args.viewer == 'ascii':
            server.game_master.register_viewer(pelita.viewer.AsciiViewer())
        if args.viewer == 'progress':
            server.game_master.register_viewer(pelita.viewer.ProgressViewer())
        if args.viewer == 'null':
            pass

        # Adding the result printer to the viewers.
        server.game_master.register_viewer(ResultPrinter(args.parseable_output))

        if args.viewer == 'tk' or args.external_controller:
            controller = pelita.simplesetup.SimpleController(server.game_master, args.controller)
            print("Controller listening on %s" % controller.socket_addr)
            config["controller-addr"] = controller.socket_addr
            def runner():
                controller.run()
                server.exit_teams()
        else:
            def runner():
                server.run()

    if args.viewer.startswith('tk'):
        # Something on OS X prevents Tk from running in a forked process.
        # Therefore we cannot use multiprocessing here. subprocess works, though.
        delay = int(1000./args.fps)
        if args.viewer == 'tk':
            sync_address_tk = config["controller-addr"].replace('*', 'localhost')
        else:
            sync_address_tk = None

        subscribe_sock = config["publish-addr"].replace('*', 'localhost')
        tkprocess = run_external_viewer(subscribe_sock, sync_address_tk, args.geometry, delay)
        external_viewers.append(tkprocess)

        if not sync_address_tk:
            time.sleep(0.5)

    with autoclose_externals(external_viewers, external_players):
        runner()


if __name__ == '__main__':
    run_game()

